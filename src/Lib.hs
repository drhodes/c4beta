{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
module Lib where

import Data.List
import Language.C
import Language.C.Analysis.AstAnalysis
import Language.C.Syntax.AST
import Language.C.Analysis.TravMonad
import Language.C.System.GCC
import System.Console.GetOpt
import System.Environment
import System.Exit
import System.IO
import Control.Monad.IO.Class
import Control.Monad
import qualified Data.List as DL
import Types
import qualified RegPool as RP
import Language.C.Data.Error
import qualified BetaCpu.Types as BT 
import BetaCpu.Instructions
import qualified BetaCpu.ToBeta as TB 
import qualified BetaCpu.Util as BCU


processFile :: CLanguage -> [String] -> FilePath -> IO ()
processFile lang cppOpts file =
  do hPutStr stderr $ file ++ ": "
     let outFile = file ++ ".uasm"
     result <- parseCFile (newGCC "gcc") Nothing cppOpts file
     
     case result of
       Left err -> hPutStrLn stderr ('\n' : show err)
       Right tu -> case runTrav_ (body tu lang) of
                     Left errs -> hPutStrLn stderr ('\n' : concatMap show errs)
                     Right (asm, errs) -> do
                       TB.toBetaEdit (RP.allocateRegs asm) >>= BCU.dump
                       BCU.run (RP.allocateRegs asm)
                       
body :: CTranslUnit -> CLanguage -> Trav s BT.AsmEdit
body tu lang = do modifyOptions (\opts -> opts { language = lang })
                  analyseAST tu
                  cTranslUnit tu

setupStack ws@(BT.Words space) =
    do allocate ws "allocation for setup stack"
       br (BT.Label "__start") "branching to start code"
       let bytes = space * 4
       skip bytes
       lbl "__start"
       cmove 0x100 BT.sp "this is setting the stack pointer"
       br (BT.Label "__function_main") "start the show"
       

cTranslUnit :: (MonadCError m, Monad m) => CTranslationUnit NodeInfo -> m BT.AsmEdit
cTranslUnit (CTranslUnit decls info) = do
  -- nts, RP.new here isn't going to cut it, the register pool logic has nonlocal span.
  --(xs, _) <- liftM DL.unzip $ mapM (compile RP.new) decls
  code <- compileSeq RP.new decls
  return $ do BCU.newline
              setupStack (BT.Words 1024)
              docs "assembly generated by c4beta"
              code

regFromInfo (NodeInfo _ _ name) = BT.VirtReg $ show (nameId name)
  
------------------------------------------------------------------
instance Compile (CExternalDeclaration NodeInfo) where
  compile rp (CDeclExt decl) = undefined
  compile rp (CFDefExt funDef) = compile rp funDef
  compile rp (CAsmExt strLit info) = undefined

------------------------------------------------------------------
functionNameFromDeclr (CDeclr (Just ident) _ _ _ _) = identToString ident
functionNameFromDeclr _ = ""


instance Compile (CFunctionDef NodeInfo) where
-- cFunDef (CFunDef [CDeclarationSpecifier a] (CDeclarator a) [CDeclaration a] (CStatement a) a
  compile rp (CFunDef decSpecs declarator declarations stmt info) = do
    specs <- compileSeq rp decSpecs
    dector <- compileOne rp declarator
    -- decls <- compileSeq rp declarations  for old style C
    block <- compileOne rp stmt

    let funcName = functionNameFromDeclr declarator
    let numArgs = length declarations
    
    done $ do lbl $ "__function_" ++ funcName
              blockStart funcName
              push BT.lp "entry pushing linkage pointer"
              push BT.bp "entry pushing base pointer"
              move BT.sp BT.bp "set base pointer"
              allocate (BT.Words numArgs) "entry seq"
              --pushSome regs "preserve registers by pushing them on the stack"
              -- decls
              dector
              block 
              blockStop funcName
    
------------------------------------------------------------------
instance Compile (CDeclarationSpecifier NodeInfo) where
  compile rp (CStorageSpec spec) = error "undefined: cDecSpec (CStorageSpec spec)"
  compile rp (CTypeSpec typeSpec) = compile rp typeSpec 
  compile rp (CTypeQual typeQual) = error "undefined: cDecSpec (CTypeQual typeQual)"

------------------------------------------------------------------
instance Compile (CTypeSpecifier NodeInfo) where
  compile rp x = done $ docs $ show $ pretty x

------------------------------------------------------------------
instance Compile (CDeclarator NodeInfo) where
  compile rp (CDeclr ident derivedDeclarators strLits attrs info) = do
    ddectors <- compileSeq rp derivedDeclarators
    done ddectors
                
  -- CDecl [CDeclarationSpecifier a] [(Maybe (CDeclarator a), Maybe (CInitializer a), Maybe (CExpression a))] a
  -- CDeclr (Maybe Ident) [CDerivedDeclarator a] (Maybe (CStringLiteral a)) [CAttribute a] a

------------------------------------------------------------------
instance Compile (CDerivedDeclarator NodeInfo) where
  compile rp (CPtrDeclr quals info) = error "undefined: CPtrDeclr"
  compile rp (CArrDeclr quals arraySize info) = error "undefined: CArrDeclr"
  
  -- * old style parameter lists have the form @Left (parameter-names)@
  compile rp (CFunDeclr (Left idents) attrs info) = do
    ats <- compileSeq rp attrs
    done $ do docs $ show idents
              docs $ show ats
    
  -- * New style parameter lists have the form @Right (declarations, isVariadic)@
  compile rp (CFunDeclr (Right (decls, isVariadic)) attrs info) = do
    -- ats <- compileSeq rp attrs
    ds <- compileSeq rp decls
    done $ do docs ". CDerivedDeclarator.CFunDeclr"
              docs $ show decls
              ds
  
------------------------------------------------------------------
instance (Compile (CAttribute NodeInfo)) where
  compile rp (CAttr ident exprs info) = do
    xs <- compileSeq rp exprs    
    done $ xs --do docs $ ". Cattribute.Cattr"
              -- docs $ show ident
              -- docs $ show xs
  
------------------------------------------------------------------
instance Compile CDecl where
  compile rp (CDecl declSpecs triples info) = do
    dspecs <- compileSeq rp declSpecs
    trips <- compileSeq rp triples
    done $ do docs ". CDecl.CDecl"
              dspecs
              trips
    
  --   --fail "cDecl (CDecl declSpecs triples info) = undefined"


instance (Compile ( Maybe (CDeclarator NodeInfo)
                  , Maybe (CInitializer NodeInfo)
                  , Maybe (CExpression NodeInfo))) where
  compile rp (mdecl, minit, mexpr) = do
    md <- case mdecl of Just mdecl' -> compileOne rp mdecl'
                        Nothing -> return BCU.nop
    -- what is minit?
    mi <- case minit of Just minit' -> compileOne rp minit'
                        Nothing -> return BCU.nop
    (me, reg) <- case mexpr of Just mexpr' -> compile rp mexpr'
                               Nothing -> return (BCU.nop, Nothing)
      
    let code = do docs "compiling triple"
                  md
                  mi
                  me
    return (code, reg)
  
instance (Compile (CInitializer NodeInfo)) where
  compile rp (CInitExpr expr info) = do
    (code, rx) <- compileExpr rp expr
    return (code, Just rx)
  
  compile rp (CInitList initList info) = error ("undefined  (CInitList initList info)")
  
------------------------------------------------------------------
instance Compile (CCompoundBlockItem NodeInfo) where
  compile rp (CBlockStmt stmt) = compile rp stmt
  compile rp (CBlockDecl decl) = compile rp decl
-- GNU C, not implemented yet.
  compile rp (CNestedFunDef funcDef) = error "undefined: blockStmt (CNestedFunDef funcDef)"

instance Compile (CStatement NodeInfo) where
  -- zxcv zxcv zxcv zxcv 
  compile rp (CCompound [] blockItems info) = do
    xs <- compileSeq rp blockItems -- fail "undefined: cStmt (CCompound [] blockItems info)"
    done $ if DL.null xs
           then docs "empty statement block"
           else xs

  -- asdf asdf
  compile rp (CCompound idents blockItems info) = do
    xs <- compileSeq rp blockItems
    done $ if DL.null xs
           then docs "empty statement block"
           else xs

  -- if statement 
  compile rp (CIf expr stmt1 Nothing info) = do
    (cond, rx) <- compileExpr rp expr
    clause1 <- compileOne rp stmt1
    done $ do docs "if statment without else clause"
              cond 
              bf rx (BT.Label "Lendif") "branch"
              clause1
              lbl "Lendif"

  -- if statement with else clause
  compile rp (CIf expr stmt1 (Just stmt2) info) = do
    
    (cond, rx) <- compileExpr rp expr
    
    clause1 <- compileOne rp stmt1 
    clause2 <- compileOne rp stmt2
   
    let code = do cond
                  bf rx (BT.Label "Lelse") ""
                  clause1
                  br (BT.Label "Lendif") ""
                  lbl "Lelse"
                  clause2
                  lbl "Lendif"
    return (code, Nothing)

  -- returning, this means we're in the Callee.
  compile _ (CReturn Nothing info) = do    
    done $ do docs "returning"
              docs "EXIT SEQUENCE"
              move BT.bp BT.sp "deallocate space for locals"
              pop BT.bp
              pop BT.lp
              jmp1 BT.lp
              
  compile rp (CReturn (Just expr) a) = do
    (code, rx) <- compileExpr rp expr
    done $ do docs "returning"
              -- docs $ show code
              move rx BT.retReg "convention moves the value into R0"
              docs "EXIT SEQUENCE"
              move BT.bp BT.sp "deallocate space for locals"
              pop BT.bp
              pop BT.lp
              jmp1 BT.lp

                
  compile _ x = fail $ show x


done edit = return (edit, Nothing)

-- preserveAllRegisters = do
--   st R1 


instance Compile (CExpression NodeInfo) where
  compile rp (CComma expr info) = fail "cExpr CComma expr info = "
  compile rp (CAssign binop e1 e2 info) = fail "cExpr CAssign binop e1 e2 info ="
  compile rp (CCond e1 Nothing e2 info) = fail "cExpr CCond e1 Nothing e2 info ="
  compile rp (CCond e1 (Just e2) e3 info) = fail "cExpr CCond e1 (Just e2) e3 info ="

  -- cExpr CBinary CBinaryOp (CExpression a) (CExpression a) a
  -- cExpr CCast (CDeclaration a) (CExpression a) a
  -- cExpr CUnary CUnaryOp (CExpression a) a
  -- cExpr CSizeofExpr (CExpression a) a
  -- cExpr CSizeofType (CDeclaration a) a
  -- cExpr CAlignofExpr (CExpression a) a
  -- cExpr CAlignofType (CDeclaration a) a
  -- cExpr CComplexReal (CExpression a) a
  -- cExpr CComplexImag (CExpression a) a
  -- cExpr CIndex (CExpression a) (CExpression a) a
  compile rp (CCall expr exprs info) = do
    (code, rx) <- compileExpr rp expr 
    let funcName = "__function_" ++ (TB.toBetaString code)

    (codes, rxs) <- liftM DL.unzip $ mapM (compileExpr rp) exprs
    return ( do docs $ "ENTRY SEQ FOR: " ++ (show code)
                docs $ "pushing registers: " ++ (show rxs)
                sequence_ codes                
                mapM (flip push "pushing args") (reverse rxs)
                br2 (BT.Label funcName) BT.lp ("branching to " ++ funcName)
                deallocate (BT.Words $ length codes) ("deallocating " ++ funcName)
           , Just rx)
    
  -- cExpr CMember (CExpression a) Ident Bool a
  compile rp c@(CVar ident info) = do
    let code = do asmIdent $ identToString ident
        rx = regFromInfo info
    return (code, Just rx)
    
  compile rp c@(CConst const) = compile rp const
  -- --integer, character, floating point and string constants
  -- cExpr CCompoundLit (CDeclaration a) (CInitializerList a) a
  -- cExpr C99 compound literal
  -- cExpr CStatExpr (CStatement a) a
  -- cExpr GNU C compound statement as expr
  -- cExpr CLabAddrExpr Ident a
  -- cExpr GNU C address of label
  -- cExpr CBuiltinExpr (CBuiltinThing a)
  --builtin expressions, see CBuiltin
  compile _ x = fail $ "Haven't implemented an expression rule: " ++ show x

instance Compile (CConstant NodeInfo) where
  compile rp (CIntConst n info) = do
    let c = fromIntegral $ getCInteger n :: Int
        rx = regFromInfo info
        code = cmove c rx "move constant to register"
                  
    return (code, Just rx)
    
  compile rp (CCharConst char _) = fail $ "Haven't implmented: cConstant chars " ++ show char
  compile rp (CFloatConst float _) = fail  $ "Haven't implmented: cConstant floats " ++ show float
  compile ro (CStrConst str _) = fail $ "Haven't implmented: cConstant strings " ++ show str
  
main :: IO ()
main =
  do args <- getArgs
     let (cppOpts, files) = partition (isPrefixOf "-") args
     mapM_ (processFile GNU99 cppOpts) files




