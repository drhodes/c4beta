{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
module Lib where

import Data.List
import Language.C
import Language.C.Analysis.AstAnalysis
import Language.C.Syntax.AST
import Language.C.Analysis.TravMonad
import Language.C.System.GCC
import System.Console.GetOpt
import System.Environment
import System.Exit
import System.IO
import Control.Monad.IO.Class
import Control.Monad
import qualified Data.List as DL
import Types
import qualified RegPool as RP
import Language.C.Data.Error
import qualified BetaCpu.Types as BT 
import BetaCpu.Instructions
import qualified BetaCpu.ToBeta as TB 
import qualified BetaCpu.Util as BCU

processFile :: CLanguage -> [String] -> FilePath -> IO ()
processFile lang cppOpts file =
  do hPutStr stderr $ file ++ ": "
     let outFile = file ++ ".uasm"
     result <- parseCFile (newGCC "gcc") Nothing cppOpts file
     
     case result of
       Left err -> hPutStrLn stderr ('\n' : show err)
       Right tu -> case runTrav_ (body tu lang) of
                     Left errs -> hPutStrLn stderr ('\n' : concatMap show errs)
                     Right (asm, errs) -> do
                       --let prog = concat $ DL.intersperse "\n" (map show asmProgram)
                       BCU.run asm
                       --writeFile outFile "food" --(prog ++ "\n")

body :: CTranslUnit -> CLanguage -> Trav s BT.AsmEdit
body tu lang = do modifyOptions (\opts -> opts { language = lang })
                  analyseAST tu
                  cTranslUnit tu

cTranslUnit :: (MonadCError m, Monad m) => CTranslationUnit NodeInfo -> m BT.AsmEdit
cTranslUnit (CTranslUnit decls info) = do
  -- nts, RP.new here isn't going to cut it, the register pool logic has nonlocal span.
  xs <- mapM (compile RP.new) decls
  return $ do BCU.newline
              docs "assembly generated by c4beta"
              sequence_ xs
  
------------------------------------------------------------------
instance Compile (CExternalDeclaration NodeInfo) where
  compile rp (CDeclExt decl) = undefined
  compile rp (CFDefExt funDef) = compile rp funDef
  compile rp (CAsmExt strLit info) = undefined

------------------------------------------------------------------
instance Compile (CFunctionDef NodeInfo) where
-- cFunDef (CFunDef [CDeclarationSpecifier a] (CDeclarator a) [CDeclaration a] (CStatement a) a
  compile rp (CFunDef decSpecs declarator declarations stmt info) = do
    specs <- compileSeq rp decSpecs
    dector <- compile rp declarator
    decls <- compileSeq rp declarations 
    block <- compile rp stmt

    return $ do docs $ "function"
                specs
                decls
                dector
                blockStart "start"
                block 
                blockStart "stop"
                docs "leave result in R0"
                docs "leave stack data intact, included stacked args"
                docs "leave regs (except R0) unchanged"
                docs "branch to return address"

------------------------------------------------------------------
instance Compile (CDeclarationSpecifier NodeInfo) where
  compile rp (CStorageSpec spec) = error "undefined: cDecSpec (CStorageSpec spec)"
  compile rp (CTypeSpec typeSpec) = compile rp typeSpec 
  compile rp (CTypeQual typeQual) = error "undefined: cDecSpec (CTypeQual typeQual)"

------------------------------------------------------------------
instance Compile (CTypeSpecifier NodeInfo) where
  compile rp x = return $ docs $ show $ pretty x

------------------------------------------------------------------
instance Compile (CDeclarator NodeInfo) where
  compile rp (CDeclr ident derivedDeclarators strLits attrs info) = do
    ddectors <- compileSeq rp derivedDeclarators
    
    return $ do docs $ show $ ident
                
                ddectors



                
  -- CDecl [CDeclarationSpecifier a] [(Maybe (CDeclarator a), Maybe (CInitializer a), Maybe (CExpression a))] a
  -- CDeclr (Maybe Ident) [CDerivedDeclarator a] (Maybe (CStringLiteral a)) [CAttribute a] a

------------------------------------------------------------------
instance Compile (CDerivedDeclarator NodeInfo) where
  compile rp (CPtrDeclr quals info) = error "undefined: CPtrDeclr"
  compile rp (CArrDeclr quals arraySize info) = error "undefined: CArrDeclr"
  
  -- * old style parameter lists have the form @Left (parameter-names)@
  compile rp (CFunDeclr (Left idents) attrs info) = do
    --ids <- mapM (compile rp) idents
    ats <- compileSeq rp attrs
    return $ do docs $ show idents
                docs $ show ats
                
  -- * New style parameter lists have the form @Right (declarations, isVariadic)@
  compile rp (CFunDeclr (Right (decls, isVar)) attrs info) = do
    -- ats <- compileSeq rp attrs
    ds <- compileSeq rp decls
    
    return $ do docs ". CDerivedDeclarator.CFunDeclr"
                ds

------------------------------------------------------------------
instance (Compile (CAttribute NodeInfo)) where
  compile rp (CAttr ident exprs info) = do
    xs <- compileSeq rp exprs    
    return $ do docs $ ". Cattribute.Cattr"
                docs $ show ident
                docs $ show xs

  
------------------------------------------------------------------
instance Compile CDecl where
  compile rp (CDecl declSpecs triples info) = do
    dspecs <- compileSeq rp declSpecs
    trips <- compileSeq rp triples
    return $ do docs ". CDecl.CDecl"
                dspecs
                trips
    
    --fail "cDecl (CDecl declSpecs triples info) = undefined"


instance (Compile ( Maybe (CDeclarator NodeInfo)
                  , Maybe (CInitializer NodeInfo)
                  , Maybe (CExpression NodeInfo))) where
  compile rp (mdecl, minit, mexpr) = do
    md <- case mdecl of Just mdecl' -> compile rp mdecl'
                        Nothing -> return BCU.nop
    -- what is minit?
    -- mi <- case minit of Just minit' -> compile rp minit'
    --                     Nothing -> return BCU.nop
    me <- case mexpr of Just mexpr' -> compile rp mexpr'
                        Nothing -> return BCU.nop
      
    return $ do docs "compiling triple"
                md
                me
--omstam(Compile (CInitializer NodeInfo))

------------------------------------------------------------------
instance Compile (CCompoundBlockItem NodeInfo) where
  compile rp (CBlockStmt stmt) = compile rp stmt
  compile rp (CBlockDecl decl) = compile rp decl
-- GNU C, not implemented yet.
  compile rp (CNestedFunDef funcDef) = error "undefined: blockStmt (CNestedFunDef funcDef)"

instance Compile (CStatement NodeInfo) where
  compile rp (CCompound [] blockItems info) = do
    --recordError "asdf"
    -- recordError (userErr $ "the sun set with a red light " ++ show info)
    -- recordError (userErr "large beans attacked the camp")
    -- throwTravError (userErr "no prisoners were taken")
    -- errs <- getErrors
    -- fail $ show errs
    xs <- compileSeq rp blockItems -- fail "undefined: cStmt (CCompound [] blockItems info)"
    return $ if DL.null xs
      then docs "empty statement block"
      else xs
           
  compile _ (CCompound idents blockItems info) =
    fail "undefined: cStmt (CCompound idents blockItems info)"

  compile rp (CIf expr stmt1 Nothing info) = do
    cond <- compile rp expr
    clause1 <- compile rp stmt1
    
    return $ do docs "if statment without else clause"
                cond                
                -- let tmp = BT.NR "tmp" BT.R1
                let (NodeInfo _ _ name) = info
                let tmp = BT.VirtReg (show $ nameId name)
                BCU.assign_vars [tmp]                
                bf tmp (BT.Label "Lendif") ""
                clause1
                lbl "Lendif"
      
  compile rp (CIf expr stmt1 (Just stmt2) info) = do
    cond <- compile rp expr
    clause1 <- compile rp stmt1 
    clause2 <- compile rp stmt2
   
    return $ do cond
                let tmp = BT.NR "tmp" BT.R1
                BCU.assign_vars [tmp]
                bf tmp (BT.Label "Lelse") ""
                clause1
                br (BT.Label "Lendif") ""
                lbl "Lelse"
                clause2
                lbl "Lendif"

  compile _ (CReturn Nothing info) = return $ docs "TODO: return void"
  compile _ (CReturn (Just expr) a) = return $ docs "TODO: retrurn a value"
  
  compile _ x = fail $ show x


instance Compile (CExpression NodeInfo) where
  compile rp (CComma expr info) = fail "cExpr CComma expr info = "
  compile rp (CAssign binop e1 e2 info) = fail "cExpr CAssign binop e1 e2 info ="
  compile rp (CCond e1 Nothing e2 info) = fail "cExpr CCond e1 Nothing e2 info ="
  compile rp (CCond e1 (Just e2) e3 info) = fail "cExpr CCond e1 (Just e2) e3 info ="

  -- cExpr CBinary CBinaryOp (CExpression a) (CExpression a) a
  -- cExpr CCast (CDeclaration a) (CExpression a) a
  -- cExpr CUnary CUnaryOp (CExpression a) a
  -- cExpr CSizeofExpr (CExpression a) a
  -- cExpr CSizeofType (CDeclaration a) a
  -- cExpr CAlignofExpr (CExpression a) a
  -- cExpr CAlignofType (CDeclaration a) a
  -- cExpr CComplexReal (CExpression a) a
  -- cExpr CComplexImag (CExpression a) a
  -- cExpr CIndex (CExpression a) (CExpression a) a
  -- cExpr CCall (CExpression a) [CExpression a] a
  -- cExpr CMember (CExpression a) Ident Bool a
  -- cExpr CVar Ident a
  compile rp c@(CConst const) = compile rp const
  -- --integer, character, floating point and string constants
  -- cExpr CCompoundLit (CDeclaration a) (CInitializerList a) a
  -- cExpr C99 compound literal
  -- cExpr CStatExpr (CStatement a) a
  -- cExpr GNU C compound statement as expr
  -- cExpr CLabAddrExpr Ident a
  -- cExpr GNU C address of label
  -- cExpr CBuiltinExpr (CBuiltinThing a)
  --builtin expressions, see CBuiltin
  compile _ x = fail $ show x


instance Compile (CConstant NodeInfo) where
  compile rp (CIntConst n info) = do
    let c = fromIntegral $ getCInteger n :: Int
    
    -- build up the assembly in the writer monad
    -- these four lines are building assembly.
    return $ do docs "naming constant"
                let creg = BT.NR "creg" BT.r1
                BCU.assign_vars [creg]
                cmove c creg "move constant to register"
                
  compile rp (CCharConst char _) = fail $ "Haven't implmented: cConstant chars " ++ show char
  compile rp (CFloatConst float _) = fail  $ "Haven't implmented: cConstant floats " ++ show float
  compile ro (CStrConst str _) = fail $ "Haven't implmented: cConstant strings " ++ show str
  
main :: IO ()
main =
  do args <- getArgs
     let (cppOpts, files) = partition (isPrefixOf "-") args
     mapM_ (processFile GNU99 cppOpts) files




